var Qe=(p=>(p.uninitialized="uninitialized",p.pending="pending",p.fulfilled="fulfilled",p.rejected="rejected",p))(Qe||{});function Me(e){return{status:e,isUninitialized:e==="uninitialized",isLoading:e==="pending",isSuccess:e==="fulfilled",isError:e==="rejected"}}import{createAction as U,createSlice as J,createSelector as Be,createAsyncThunk as Re,combineReducers as ke,createNextState as ie,isAnyOf as G,isAllOf as ye,isAction as ve,isPending as de,isRejected as X,isFulfilled as I,isRejectedWithValue as Z,isAsyncThunkAction as Se,prepareAutoBatched as ee,SHOULD_AUTOBATCH as oe,isPlainObject as _,nanoid as Pe}from"@reduxjs/toolkit";var Ce=_;function pe(e,r){if(e===r||!(Ce(e)&&Ce(r)||Array.isArray(e)&&Array.isArray(r)))return r;let c=Object.keys(r),g=Object.keys(e),p=c.length===g.length,Q=Array.isArray(r)?[]:{};for(let S of c)Q[S]=pe(e[S],r[S]),p&&(p=e[S]===Q[S]);return p?e:Q}function K(e){let r=0;for(let c in e)r++;return r}var xe=e=>[].concat(...e);function we(e){return new RegExp("(^|:)//").test(e)}function Fe(){return typeof document>"u"?!0:document.visibilityState!=="hidden"}function Ae(e){return e!=null}function Ie(){return typeof navigator>"u"||navigator.onLine===void 0?!0:navigator.onLine}var dt=e=>e.replace(/\/$/,""),pt=e=>e.replace(/^\//,"");function Oe(e,r){if(!e)return r;if(!r)return e;if(we(r))return r;let c=e.endsWith("/")||!r.startsWith("?")?"/":"";return e=dt(e),r=pt(r),`${e}${c}${r}`}var qe=(...e)=>fetch(...e),ct=e=>e.status>=200&&e.status<=299,lt=e=>/ion\/(vnd\.api\+)?json/.test(e.get("content-type")||"");function Ne(e){if(!_(e))return e;let r={...e};for(let[c,g]of Object.entries(r))g===void 0&&delete r[c];return r}function ft({baseUrl:e,prepareHeaders:r=d=>d,fetchFn:c=qe,paramsSerializer:g,isJsonContentType:p=lt,jsonContentType:Q="application/json",jsonReplacer:S,timeout:E,responseHandler:M,validateStatus:f,...x}={}){return typeof fetch>"u"&&c===qe&&console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),async(n,t)=>{let{getState:m,extra:R,endpoint:y,forced:u,type:a}=t,o,{url:i,headers:s=new Headers(x.headers),params:T=void 0,responseHandler:l=M??"json",validateStatus:h=f??ct,timeout:D=E,...A}=typeof n=="string"?{url:n}:n,b,B=t.signal;D&&(b=new AbortController,t.signal.addEventListener("abort",b.abort),B=b.signal);let k={...x,signal:B,...A};s=new Headers(Ne(s)),k.headers=await r(s,{getState:m,extra:R,endpoint:y,forced:u,type:a})||s;let P=v=>typeof v=="object"&&(_(v)||Array.isArray(v)||typeof v.toJSON=="function");if(!k.headers.has("content-type")&&P(k.body)&&k.headers.set("content-type",Q),P(k.body)&&p(k.headers)&&(k.body=JSON.stringify(k.body,S)),T){let v=~i.indexOf("?")?"&":"?",$=g?g(T):new URLSearchParams(Ne(T));i+=v+$}i=Oe(e,i);let C=new Request(i,k);o={request:new Request(i,k)};let F,w=!1,q=b&&setTimeout(()=>{w=!0,b.abort()},D);try{F=await c(C)}catch(v){return{error:{status:w?"TIMEOUT_ERROR":"FETCH_ERROR",error:String(v)},meta:o}}finally{q&&clearTimeout(q),b?.signal.removeEventListener("abort",b.abort)}let N=F.clone();o.response=N;let W,H="";try{let v;if(await Promise.all([d(F,l).then($=>W=$,$=>v=$),N.text().then($=>H=$,()=>{})]),v)throw v}catch(v){return{error:{status:"PARSING_ERROR",originalStatus:F.status,data:H,error:String(v)},meta:o}}return h(F,W)?{data:W,meta:o}:{error:{status:F.status,data:W},meta:o}};async function d(n,t){if(typeof t=="function")return t(n);if(t==="content-type"&&(t=p(n.headers)?"json":"text"),t==="json"){let m=await n.text();return m.length?JSON.parse(m):null}return n.text()}}var j=class{constructor(r,c=void 0){this.value=r;this.meta=c}};async function mt(e=0,r=5){let c=Math.min(e,r),g=~~((Math.random()+.4)*(300<<c));await new Promise(p=>setTimeout(Q=>p(Q),g))}function gt(e){throw Object.assign(new j({error:e}),{throwImmediately:!0})}var Ke={},Tt=(e,r)=>async(c,g,p)=>{let Q=[5,(r||Ke).maxRetries,(p||Ke).maxRetries].filter(x=>x!==void 0),[S]=Q.slice(-1),M={maxRetries:S,backoff:mt,retryCondition:(x,d,{attempt:n})=>n<=S,...r,...p},f=0;for(;;)try{let x=await e(c,g,p);if(x.error)throw new j(x);return x}catch(x){if(f++,x.throwImmediately){if(x instanceof j)return x.value;throw x}if(x instanceof j&&!M.retryCondition(x.value.error,c,{attempt:f,baseQueryApi:g,extraOptions:p}))return x.value;await M.backoff(f,M.maxRetries)}},ht=Object.assign(Tt,{fail:gt});var z=U("__rtkq/focused"),te=U("__rtkq/unfocused"),V=U("__rtkq/online"),ne=U("__rtkq/offline"),De=!1;function Qt(e,r){function c(){let g=()=>e(z()),p=()=>e(te()),Q=()=>e(V()),S=()=>e(ne()),E=()=>{window.document.visibilityState==="visible"?g():p()};return De||typeof window<"u"&&window.addEventListener&&(window.addEventListener("visibilitychange",E,!1),window.addEventListener("focus",g,!1),window.addEventListener("online",Q,!1),window.addEventListener("offline",S,!1),De=!0),()=>{window.removeEventListener("focus",g),window.removeEventListener("visibilitychange",E),window.removeEventListener("online",Q),window.removeEventListener("offline",S),De=!1}}return r?r(e,{onFocus:z,onFocusLost:te,onOffline:ne,onOnline:V}):c()}function le(e){return e.type==="query"}function je(e){return e.type==="mutation"}function ae(e,r,c,g,p,Q){return Rt(e)?e(r,c,g,p).map(ce).map(Q):Array.isArray(e)?e.map(ce).map(Q):[]}function Rt(e){return typeof e=="function"}function ce(e){return typeof e=="string"?{type:e}:e}import{isDraftable as St,produceWithPatches as xt}from"immer";import"@reduxjs/toolkit";function Ue(e,r){return e.catch(r)}var re=Symbol("forceQueryFn"),se=e=>typeof e[re]=="function";function Le({serializeQueryArgs:e,queryThunk:r,mutationThunk:c,api:g,context:p}){let Q=new Map,S=new Map,{unsubscribeQueryResult:E,removeMutationResult:M,updateSubscriptionOptions:f}=g.internalActions;return{buildInitiateQuery:R,buildInitiateMutation:y,getRunningQueryThunk:x,getRunningMutationThunk:d,getRunningQueriesThunk:n,getRunningMutationsThunk:t};function x(u,a){return o=>{let i=p.endpointDefinitions[u],s=e({queryArgs:a,endpointDefinition:i,endpointName:u});return Q.get(o)?.[s]}}function d(u,a){return o=>S.get(o)?.[a]}function n(){return u=>Object.values(Q.get(u)||{}).filter(Ae)}function t(){return u=>Object.values(S.get(u)||{}).filter(Ae)}function m(u){}function R(u,a){let o=(i,{subscribe:s=!0,forceRefetch:T,subscriptionOptions:l,[re]:h,...D}={})=>(A,b)=>{let B=e({queryArgs:i,endpointDefinition:a,endpointName:u}),k=r({...D,type:"query",subscribe:s,forceRefetch:T,subscriptionOptions:l,endpointName:u,originalArgs:i,queryCacheKey:B,[re]:h}),P=g.endpoints[u].select(i),C=A(k),O=P(b());let{requestId:F,abort:w}=C,q=O.requestId!==F,N=Q.get(A)?.[B],W=()=>P(b()),H=Object.assign(h?C.then(W):q&&!N?Promise.resolve(O):Promise.all([N,C]).then(W),{arg:i,requestId:F,subscriptionOptions:l,queryCacheKey:B,abort:w,async unwrap(){let v=await H;if(v.isError)throw v.error;return v.data},refetch:()=>A(o(i,{subscribe:!1,forceRefetch:!0})),unsubscribe(){s&&A(E({queryCacheKey:B,requestId:F}))},updateSubscriptionOptions(v){H.subscriptionOptions=v,A(f({endpointName:u,requestId:F,queryCacheKey:B,options:v}))}});if(!N&&!q&&!h){let v=Q.get(A)||{};v[B]=H,Q.set(A,v),H.then(()=>{delete v[B],K(v)||Q.delete(A)})}return H};return o}function y(u){return(a,{track:o=!0,fixedCacheKey:i}={})=>(s,T)=>{let l=c({type:"mutation",endpointName:u,originalArgs:a,track:o,fixedCacheKey:i}),h=s(l);let{requestId:D,abort:A,unwrap:b}=h,B=Ue(h.unwrap().then(O=>({data:O})),O=>({error:O})),k=()=>{s(M({requestId:D,fixedCacheKey:i}))},P=Object.assign(B,{arg:h.arg,requestId:D,abort:A,unwrap:b,reset:k}),C=S.get(s)||{};return S.set(s,C),C[D]=P,P.then(()=>{delete C[D],K(C)||S.delete(s)}),i&&(C[i]=P,P.then(()=>{C[i]===P&&(delete C[i],K(C)||S.delete(s))})),P}}}function He(e){return e}function _e({reducerPath:e,baseQuery:r,context:{endpointDefinitions:c},serializeQueryArgs:g,api:p,assertTagType:Q}){let S=(a,o,i,s)=>(T,l)=>{let h=c[a],D=g({queryArgs:o,endpointDefinition:h,endpointName:a});if(T(p.internalActions.queryResultPatched({queryCacheKey:D,patches:i})),!s)return;let A=p.endpoints[a].select(o)(l()),b=ae(h.providesTags,A.data,void 0,o,{},Q);T(p.internalActions.updateProvidedBy({queryCacheKey:D,providedTags:b}))},E=(a,o,i,s=!0)=>(T,l)=>{let D=p.endpoints[a].select(o)(l()),A={patches:[],inversePatches:[],undo:()=>T(p.util.patchQueryData(a,o,A.inversePatches,s))};if(D.status==="uninitialized")return A;let b;if("data"in D)if(St(D.data)){let[B,k,P]=xt(D.data,i);A.patches.push(...k),A.inversePatches.push(...P),b=B}else b=i(D.data),A.patches.push({op:"replace",path:[],value:b}),A.inversePatches.push({op:"replace",path:[],value:D.data});return A.patches.length===0||T(p.util.patchQueryData(a,o,A.patches,s)),A},M=(a,o,i)=>s=>s(p.endpoints[a].initiate(o,{subscribe:!1,forceRefetch:!0,[re]:()=>({data:i})})),f=async(a,{signal:o,abort:i,rejectWithValue:s,fulfillWithValue:T,dispatch:l,getState:h,extra:D})=>{let A=c[a.endpointName];try{let b=He,B,k={signal:o,abort:i,dispatch:l,getState:h,extra:D,endpoint:a.endpointName,type:a.type,forced:a.type==="query"?x(a,h()):void 0,queryCacheKey:a.type==="query"?a.queryCacheKey:void 0},P=a.type==="query"?a[re]:void 0;if(P?B=P():A.query?(B=await r(A.query(a.originalArgs),k,A.extraOptions),A.transformResponse&&(b=A.transformResponse)):B=await A.queryFn(a.originalArgs,k,A.extraOptions,C=>r(C,k,A.extraOptions)),typeof process<"u",B.error)throw new j(B.error,B.meta);return T(await b(B.data,B.meta,a.originalArgs),{fulfilledTimeStamp:Date.now(),baseQueryMeta:B.meta,[oe]:!0})}catch(b){let B=b;if(B instanceof j){let k=He;A.query&&A.transformErrorResponse&&(k=A.transformErrorResponse);try{return s(await k(B.value,B.meta,a.originalArgs),{baseQueryMeta:B.meta,[oe]:!0})}catch(P){B=P}}throw typeof process<"u",console.error(B),B}};function x(a,o){let i=o[e]?.queries?.[a.queryCacheKey],s=o[e]?.config.refetchOnMountOrArgChange,T=i?.fulfilledTimeStamp,l=a.forceRefetch??(a.subscribe&&s);return l?l===!0||(Number(new Date)-Number(T))/1e3>=l:!1}let d=Re(`${e}/executeQuery`,f,{getPendingMeta(){return{startedTimeStamp:Date.now(),[oe]:!0}},condition(a,{getState:o}){let i=o(),s=i[e]?.queries?.[a.queryCacheKey],T=s?.fulfilledTimeStamp,l=a.originalArgs,h=s?.originalArgs,D=c[a.endpointName];return se(a)?!0:s?.status==="pending"?!1:x(a,i)||le(D)&&D?.forceRefetch?.({currentArg:l,previousArg:h,endpointState:s,state:i})?!0:!T},dispatchConditionRejection:!0}),n=Re(`${e}/executeMutation`,f,{getPendingMeta(){return{startedTimeStamp:Date.now(),[oe]:!0}}}),t=a=>"force"in a,m=a=>"ifOlderThan"in a,R=(a,o,i)=>(s,T)=>{let l=t(i)&&i.force,h=m(i)&&i.ifOlderThan,D=(b=!0)=>{let B={forceRefetch:b,isPrefetch:!0};return p.endpoints[a].initiate(o,B)},A=p.endpoints[a].select(o)(T());if(l)s(D());else if(h){let b=A?.fulfilledTimeStamp;if(!b){s(D());return}(Number(new Date)-Number(new Date(b)))/1e3>=h&&s(D())}else s(D(!1))};function y(a){return o=>o?.meta?.arg?.endpointName===a}function u(a,o){return{matchPending:ye(de(a),y(o)),matchFulfilled:ye(I(a),y(o)),matchRejected:ye(X(a),y(o))}}return{queryThunk:d,mutationThunk:n,prefetch:R,updateQueryData:E,upsertQueryData:M,patchQueryData:S,buildMatchThunkActions:u}}function fe(e,r,c,g){return ae(c[e.meta.arg.endpointName][r],I(e)?e.payload:void 0,Z(e)?e.payload:void 0,e.meta.arg.originalArgs,"baseQueryMeta"in e.meta?e.meta.baseQueryMeta:void 0,g)}import{isDraft as At}from"immer";import{applyPatches as ze,original as Dt}from"immer";function me(e,r,c){let g=e[r];g&&c(g)}function Y(e){return("arg"in e?e.arg.fixedCacheKey:e.fixedCacheKey)??e.requestId}function Ve(e,r,c){let g=e[Y(r)];g&&c(g)}var ue={};function We({reducerPath:e,queryThunk:r,mutationThunk:c,context:{endpointDefinitions:g,apiUid:p,extractRehydrationInfo:Q,hasRehydrationInfo:S},assertTagType:E,config:M}){let f=U(`${e}/resetApiState`),x=J({name:`${e}/queries`,initialState:ue,reducers:{removeQueryResult:{reducer(o,{payload:{queryCacheKey:i}}){delete o[i]},prepare:ee()},queryResultPatched:{reducer(o,{payload:{queryCacheKey:i,patches:s}}){me(o,i,T=>{T.data=ze(T.data,s.concat())})},prepare:ee()}},extraReducers(o){o.addCase(r.pending,(i,{meta:s,meta:{arg:T}})=>{let l=se(T);i[T.queryCacheKey]??={status:"uninitialized",endpointName:T.endpointName},me(i,T.queryCacheKey,h=>{h.status="pending",h.requestId=l&&h.requestId?h.requestId:s.requestId,T.originalArgs!==void 0&&(h.originalArgs=T.originalArgs),h.startedTimeStamp=s.startedTimeStamp})}).addCase(r.fulfilled,(i,{meta:s,payload:T})=>{me(i,s.arg.queryCacheKey,l=>{if(l.requestId!==s.requestId&&!se(s.arg))return;let{merge:h}=g[s.arg.endpointName];if(l.status="fulfilled",h)if(l.data!==void 0){let{fulfilledTimeStamp:D,arg:A,baseQueryMeta:b,requestId:B}=s,k=ie(l.data,P=>h(P,T,{arg:A.originalArgs,baseQueryMeta:b,fulfilledTimeStamp:D,requestId:B}));l.data=k}else l.data=T;else l.data=g[s.arg.endpointName].structuralSharing??!0?pe(At(l.data)?Dt(l.data):l.data,T):T;delete l.error,l.fulfilledTimeStamp=s.fulfilledTimeStamp})}).addCase(r.rejected,(i,{meta:{condition:s,arg:T,requestId:l},error:h,payload:D})=>{me(i,T.queryCacheKey,A=>{if(!s){if(A.requestId!==l)return;A.status="rejected",A.error=D??h}})}).addMatcher(S,(i,s)=>{let{queries:T}=Q(s);for(let[l,h]of Object.entries(T))(h?.status==="fulfilled"||h?.status==="rejected")&&(i[l]=h)})}}),d=J({name:`${e}/mutations`,initialState:ue,reducers:{removeMutationResult:{reducer(o,{payload:i}){let s=Y(i);s in o&&delete o[s]},prepare:ee()}},extraReducers(o){o.addCase(c.pending,(i,{meta:s,meta:{requestId:T,arg:l,startedTimeStamp:h}})=>{l.track&&(i[Y(s)]={requestId:T,status:"pending",endpointName:l.endpointName,startedTimeStamp:h})}).addCase(c.fulfilled,(i,{payload:s,meta:T})=>{T.arg.track&&Ve(i,T,l=>{l.requestId===T.requestId&&(l.status="fulfilled",l.data=s,l.fulfilledTimeStamp=T.fulfilledTimeStamp)})}).addCase(c.rejected,(i,{payload:s,error:T,meta:l})=>{l.arg.track&&Ve(i,l,h=>{h.requestId===l.requestId&&(h.status="rejected",h.error=s??T)})}).addMatcher(S,(i,s)=>{let{mutations:T}=Q(s);for(let[l,h]of Object.entries(T))(h?.status==="fulfilled"||h?.status==="rejected")&&l!==h?.requestId&&(i[l]=h)})}}),n=J({name:`${e}/invalidation`,initialState:ue,reducers:{updateProvidedBy:{reducer(o,i){let{queryCacheKey:s,providedTags:T}=i.payload;for(let l of Object.values(o))for(let h of Object.values(l)){let D=h.indexOf(s);D!==-1&&h.splice(D,1)}for(let{type:l,id:h}of T){let D=(o[l]??={})[h||"__internal_without_id"]??=[];D.includes(s)||D.push(s)}},prepare:ee()}},extraReducers(o){o.addCase(x.actions.removeQueryResult,(i,{payload:{queryCacheKey:s}})=>{for(let T of Object.values(i))for(let l of Object.values(T)){let h=l.indexOf(s);h!==-1&&l.splice(h,1)}}).addMatcher(S,(i,s)=>{let{provided:T}=Q(s);for(let[l,h]of Object.entries(T))for(let[D,A]of Object.entries(h)){let b=(i[l]??={})[D||"__internal_without_id"]??=[];for(let B of A)b.includes(B)||b.push(B)}}).addMatcher(G(I(r),Z(r)),(i,s)=>{let T=fe(s,"providesTags",g,E),{queryCacheKey:l}=s.meta.arg;n.caseReducers.updateProvidedBy(i,n.actions.updateProvidedBy({queryCacheKey:l,providedTags:T}))})}}),t=J({name:`${e}/subscriptions`,initialState:ue,reducers:{updateSubscriptionOptions(o,i){},unsubscribeQueryResult(o,i){},internal_getRTKQSubscriptions(){}}}),m=J({name:`${e}/internalSubscriptions`,initialState:ue,reducers:{subscriptionsUpdated:{reducer(o,i){return ze(o,i.payload)},prepare:ee()}}}),R=J({name:`${e}/config`,initialState:{online:Ie(),focused:Fe(),middlewareRegistered:!1,...M},reducers:{middlewareRegistered(o,{payload:i}){o.middlewareRegistered=o.middlewareRegistered==="conflict"||p!==i?"conflict":!0}},extraReducers:o=>{o.addCase(V,i=>{i.online=!0}).addCase(ne,i=>{i.online=!1}).addCase(z,i=>{i.focused=!0}).addCase(te,i=>{i.focused=!1}).addMatcher(S,i=>({...i}))}}),y=ke({queries:x.reducer,mutations:d.reducer,provided:n.reducer,subscriptions:m.reducer,config:R.reducer}),u=(o,i)=>y(f.match(i)?void 0:o,i),a={...R.actions,...x.actions,...t.actions,...m.actions,...d.actions,...n.actions,resetApiState:f};return{reducer:u,actions:a}}var ge=Symbol.for("RTKQ/skipToken"),Ge={status:"uninitialized"},$e=ie(Ge,()=>{}),Je=ie(Ge,()=>{});function Ye({serializeQueryArgs:e,reducerPath:r,createSelector:c}){let g=d=>$e,p=d=>Je;return{buildQuerySelector:E,buildMutationSelector:M,selectInvalidatedBy:f,selectCachedArgsForQuery:x};function Q(d){return{...d,...Me(d.status)}}function S(d){return d[r]}function E(d,n){return t=>{let m=e({queryArgs:t,endpointDefinition:n,endpointName:d});return c(t===ge?g:u=>S(u)?.queries?.[m]??$e,Q)}}function M(){return d=>{let n;return typeof d=="object"?n=Y(d)??ge:n=d,c(n===ge?p:R=>S(R)?.mutations?.[n]??Je,Q)}}function f(d,n){let t=d[r],m=new Set;for(let R of n.map(ce)){let y=t.provided[R.type];if(!y)continue;let u=(R.id!==void 0?y[R.id]:xe(Object.values(y)))??[];for(let a of u)m.add(a)}return xe(Array.from(m.values()).map(R=>{let y=t.queries[R];return y?[{queryCacheKey:R,endpointName:y.endpointName,originalArgs:y.originalArgs}]:[]}))}function x(d,n){return Object.values(d[r].queries).filter(t=>t?.endpointName===n&&t.status!=="uninitialized").map(t=>t.originalArgs)}}import{formatProdErrorMessage as bt}from"@reduxjs/toolkit";var Xe=WeakMap?new WeakMap:void 0,Te=({endpointName:e,queryArgs:r})=>{let c="",g=Xe?.get(r);if(typeof g=="string")c=g;else{let p=JSON.stringify(r,(Q,S)=>(S=typeof S=="bigint"?{$bigint:S.toString()}:S,S=_(S)?Object.keys(S).sort().reduce((E,M)=>(E[M]=S[M],E),{}):S,S));_(r)&&Xe?.set(r,p),c=p}return`${e}(${c})`};import{weakMapMemoize as Ze}from"reselect";function be(...e){return function(c){let g=Ze(f=>c.extractRehydrationInfo?.(f,{reducerPath:c.reducerPath??"api"})),p={reducerPath:"api",keepUnusedDataFor:60,refetchOnMountOrArgChange:!1,refetchOnFocus:!1,refetchOnReconnect:!1,invalidationBehavior:"delayed",...c,extractRehydrationInfo:g,serializeQueryArgs(f){let x=Te;if("serializeQueryArgs"in f.endpointDefinition){let d=f.endpointDefinition.serializeQueryArgs;x=n=>{let t=d(n);return typeof t=="string"?t:Te({...n,queryArgs:t})}}else c.serializeQueryArgs&&(x=c.serializeQueryArgs);return x(f)},tagTypes:[...c.tagTypes||[]]},Q={endpointDefinitions:{},batch(f){f()},apiUid:Pe(),extractRehydrationInfo:g,hasRehydrationInfo:Ze(f=>g(f)!=null)},S={injectEndpoints:M,enhanceEndpoints({addTagTypes:f,endpoints:x}){if(f)for(let d of f)p.tagTypes.includes(d)||p.tagTypes.push(d);if(x)for(let[d,n]of Object.entries(x))typeof n=="function"?n(Q.endpointDefinitions[d]):Object.assign(Q.endpointDefinitions[d]||{},n);return S}},E=e.map(f=>f.init(S,p,Q));function M(f){let x=f.endpoints({query:d=>({...d,type:"query"}),mutation:d=>({...d,type:"mutation"})});for(let[d,n]of Object.entries(x)){if(f.overrideExisting!==!0&&d in Q.endpointDefinitions){if(f.overrideExisting==="throw")throw new Error(bt(39));typeof process<"u";continue}Q.endpointDefinitions[d]=n;for(let t of E)t.injectEndpoint(d,n)}return S}return S.injectEndpoints({endpoints:c.endpoints})}}import{formatProdErrorMessage as Et}from"@reduxjs/toolkit";var Mt=Symbol();function Bt(){return function(){throw new Error(Et(33))}}import{enablePatches as Ct}from"immer";function L(e,...r){return Object.assign(e,...r)}import{produceWithPatches as kt}from"immer";var et=({api:e,queryThunk:r,internalState:c})=>{let g=`${e.reducerPath}/subscriptions`,p=null,Q=null,{updateSubscriptionOptions:S,unsubscribeQueryResult:E}=e.internalActions,M=(t,m)=>{if(S.match(m)){let{queryCacheKey:y,requestId:u,options:a}=m.payload;return t?.[y]?.[u]&&(t[y][u]=a),!0}if(E.match(m)){let{queryCacheKey:y,requestId:u}=m.payload;return t[y]&&delete t[y][u],!0}if(e.internalActions.removeQueryResult.match(m))return delete t[m.payload.queryCacheKey],!0;if(r.pending.match(m)){let{meta:{arg:y,requestId:u}}=m,a=t[y.queryCacheKey]??={};return a[`${u}_running`]={},y.subscribe&&(a[u]=y.subscriptionOptions??a[u]??{}),!0}let R=!1;if(r.fulfilled.match(m)||r.rejected.match(m)){let y=t[m.meta.arg.queryCacheKey]||{},u=`${m.meta.requestId}_running`;R||=!!y[u],delete y[u]}if(r.rejected.match(m)){let{meta:{condition:y,arg:u,requestId:a}}=m;if(y&&u.subscribe){let o=t[u.queryCacheKey]??={};o[a]=u.subscriptionOptions??o[a]??{},R=!0}}return R},f=()=>c.currentSubscriptions,n={getSubscriptions:f,getSubscriptionCount:t=>{let R=f()[t]??{};return K(R)},isRequestSubscribed:(t,m)=>!!f()?.[t]?.[m]};return(t,m)=>{if(p||(p=JSON.parse(JSON.stringify(c.currentSubscriptions))),e.util.resetApiState.match(t))return p=c.currentSubscriptions={},Q=null,[!0,!1];if(e.internalActions.internal_getRTKQSubscriptions.match(t))return[!1,n];let R=M(c.currentSubscriptions,t),y=!0;if(R){Q||(Q=setTimeout(()=>{let o=JSON.parse(JSON.stringify(c.currentSubscriptions)),[,i]=kt(p,()=>o);m.next(e.internalActions.subscriptionsUpdated(i)),p=o,Q=null},500));let u=typeof t.type=="string"&&!!t.type.startsWith(g),a=r.rejected.match(t)&&t.meta.condition&&!!t.meta.arg.subscribe;y=!u&&!a}return[y,!1]}};function vt(e){for(let r in e)return!1;return!0}var Pt=2147483647/1e3-1,tt=({reducerPath:e,api:r,queryThunk:c,context:g,internalState:p})=>{let{removeQueryResult:Q,unsubscribeQueryResult:S}=r.internalActions,E=G(S.match,c.fulfilled,c.rejected);function M(n){let t=p.currentSubscriptions[n];return!!t&&!vt(t)}let f={},x=(n,t,m)=>{if(E(n)){let R=t.getState()[e],{queryCacheKey:y}=S.match(n)?n.payload:n.meta.arg;d(y,R.queries[y]?.endpointName,t,R.config)}if(r.util.resetApiState.match(n))for(let[R,y]of Object.entries(f))y&&clearTimeout(y),delete f[R];if(g.hasRehydrationInfo(n)){let R=t.getState()[e],{queries:y}=g.extractRehydrationInfo(n);for(let[u,a]of Object.entries(y))d(u,a?.endpointName,t,R.config)}};function d(n,t,m,R){let u=g.endpointDefinitions[t]?.keepUnusedDataFor??R.keepUnusedDataFor;if(u===1/0)return;let a=Math.max(0,Math.min(u,Pt));if(!M(n)){let o=f[n];o&&clearTimeout(o),f[n]=setTimeout(()=>{M(n)||m.dispatch(Q({queryCacheKey:n})),delete f[n]},a*1e3)}}return x};var nt=new Error("Promise never resolved before cacheEntryRemoved."),rt=({api:e,reducerPath:r,context:c,queryThunk:g,mutationThunk:p,internalState:Q})=>{let S=Se(g),E=Se(p),M=I(g,p),f={},x=(t,m,R)=>{let y=d(t);if(g.pending.match(t)){let u=R[r].queries[y],a=m.getState()[r].queries[y];!u&&a&&n(t.meta.arg.endpointName,t.meta.arg.originalArgs,y,m,t.meta.requestId)}else if(p.pending.match(t))m.getState()[r].mutations[y]&&n(t.meta.arg.endpointName,t.meta.arg.originalArgs,y,m,t.meta.requestId);else if(M(t)){let u=f[y];u?.valueResolved&&(u.valueResolved({data:t.payload,meta:t.meta.baseQueryMeta}),delete u.valueResolved)}else if(e.internalActions.removeQueryResult.match(t)||e.internalActions.removeMutationResult.match(t)){let u=f[y];u&&(delete f[y],u.cacheEntryRemoved())}else if(e.util.resetApiState.match(t))for(let[u,a]of Object.entries(f))delete f[u],a.cacheEntryRemoved()};function d(t){return S(t)?t.meta.arg.queryCacheKey:E(t)?t.meta.arg.fixedCacheKey??t.meta.requestId:e.internalActions.removeQueryResult.match(t)?t.payload.queryCacheKey:e.internalActions.removeMutationResult.match(t)?Y(t.payload):""}function n(t,m,R,y,u){let a=c.endpointDefinitions[t],o=a?.onCacheEntryAdded;if(!o)return;let i={},s=new Promise(b=>{i.cacheEntryRemoved=b}),T=Promise.race([new Promise(b=>{i.valueResolved=b}),s.then(()=>{throw nt})]);T.catch(()=>{}),f[R]=i;let l=e.endpoints[t].select(a.type==="query"?m:R),h=y.dispatch((b,B,k)=>k),D={...y,getCacheEntry:()=>l(y.getState()),requestId:u,extra:h,updateCachedData:a.type==="query"?b=>y.dispatch(e.util.updateQueryData(t,m,b)):void 0,cacheDataLoaded:T,cacheEntryRemoved:s},A=o(m,D);Promise.resolve(A).catch(b=>{if(b!==nt)throw b})}return x};var it=({api:e,context:{apiUid:r},reducerPath:c})=>(g,p)=>{e.util.resetApiState.match(g)&&p.dispatch(e.internalActions.middlewareRegistered(r)),typeof process<"u"};var ot=({reducerPath:e,context:r,context:{endpointDefinitions:c},mutationThunk:g,queryThunk:p,api:Q,assertTagType:S,refetchQuery:E,internalState:M})=>{let{removeQueryResult:f}=Q.internalActions,x=G(I(g),Z(g)),d=G(I(g,p),X(g,p)),n=[],t=(y,u)=>{x(y)?R(fe(y,"invalidatesTags",c,S),u):d(y)?R([],u):Q.util.invalidateTags.match(y)&&R(ae(y.payload,void 0,void 0,void 0,void 0,S),u)};function m(y){for(let u in y.queries)if(y.queries[u]?.status==="pending")return!0;for(let u in y.mutations)if(y.mutations[u]?.status==="pending")return!0;return!1}function R(y,u){let a=u.getState(),o=a[e];if(n.push(...y),o.config.invalidationBehavior==="delayed"&&m(o))return;let i=n;if(n=[],i.length===0)return;let s=Q.util.selectInvalidatedBy(a,i);r.batch(()=>{let T=Array.from(s.values());for(let{queryCacheKey:l}of T){let h=o.queries[l],D=M.currentSubscriptions[l]??{};h&&(K(D)===0?u.dispatch(f({queryCacheKey:l})):h.status!=="uninitialized"&&u.dispatch(E(h)))}})}return t};var at=({reducerPath:e,queryThunk:r,api:c,refetchQuery:g,internalState:p})=>{let Q={},S=(n,t)=>{(c.internalActions.updateSubscriptionOptions.match(n)||c.internalActions.unsubscribeQueryResult.match(n))&&M(n.payload,t),(r.pending.match(n)||r.rejected.match(n)&&n.meta.condition)&&M(n.meta.arg,t),(r.fulfilled.match(n)||r.rejected.match(n)&&!n.meta.condition)&&E(n.meta.arg,t),c.util.resetApiState.match(n)&&x()};function E({queryCacheKey:n},t){let m=t.getState()[e],R=m.queries[n],y=p.currentSubscriptions[n];if(!R||R.status==="uninitialized")return;let{lowestPollingInterval:u,skipPollingIfUnfocused:a}=d(y);if(!Number.isFinite(u))return;let o=Q[n];o?.timeout&&(clearTimeout(o.timeout),o.timeout=void 0);let i=Date.now()+u;Q[n]={nextPollTimestamp:i,pollingInterval:u,timeout:setTimeout(()=>{(m.config.focused||!a)&&t.dispatch(g(R)),E({queryCacheKey:n},t)},u)}}function M({queryCacheKey:n},t){let R=t.getState()[e].queries[n],y=p.currentSubscriptions[n];if(!R||R.status==="uninitialized")return;let{lowestPollingInterval:u}=d(y);if(!Number.isFinite(u)){f(n);return}let a=Q[n],o=Date.now()+u;(!a||o<a.nextPollTimestamp)&&E({queryCacheKey:n},t)}function f(n){let t=Q[n];t?.timeout&&clearTimeout(t.timeout),delete Q[n]}function x(){for(let n of Object.keys(Q))f(n)}function d(n={}){let t=!1,m=Number.POSITIVE_INFINITY;for(let R in n)n[R].pollingInterval&&(m=Math.min(n[R].pollingInterval,m),t=n[R].skipPollingIfUnfocused||t);return{lowestPollingInterval:m,skipPollingIfUnfocused:t}}return S};var st=({api:e,context:r,queryThunk:c,mutationThunk:g})=>{let p=de(c,g),Q=X(c,g),S=I(c,g),E={};return(f,x)=>{if(p(f)){let{requestId:d,arg:{endpointName:n,originalArgs:t}}=f.meta,m=r.endpointDefinitions[n],R=m?.onQueryStarted;if(R){let y={},u=new Promise((s,T)=>{y.resolve=s,y.reject=T});u.catch(()=>{}),E[d]=y;let a=e.endpoints[n].select(m.type==="query"?t:d),o=x.dispatch((s,T,l)=>l),i={...x,getCacheEntry:()=>a(x.getState()),requestId:d,extra:o,updateCachedData:m.type==="query"?s=>x.dispatch(e.util.updateQueryData(n,t,s)):void 0,queryFulfilled:u};R(t,i)}}else if(S(f)){let{requestId:d,baseQueryMeta:n}=f.meta;E[d]?.resolve({data:f.payload,meta:n}),delete E[d]}else if(Q(f)){let{requestId:d,rejectedWithValue:n,baseQueryMeta:t}=f.meta;E[d]?.reject({error:f.payload??f.error,isUnhandledError:!n,meta:t}),delete E[d]}}};var ut=({reducerPath:e,context:r,api:c,refetchQuery:g,internalState:p})=>{let{removeQueryResult:Q}=c.internalActions,S=(M,f)=>{z.match(M)&&E(f,"refetchOnFocus"),V.match(M)&&E(f,"refetchOnReconnect")};function E(M,f){let x=M.getState()[e],d=x.queries,n=p.currentSubscriptions;r.batch(()=>{for(let t of Object.keys(n)){let m=d[t],R=n[t];if(!R||!m)continue;(Object.values(R).some(u=>u[f]===!0)||Object.values(R).every(u=>u[f]===void 0)&&x.config[f])&&(K(R)===0?M.dispatch(Q({queryCacheKey:t})):m.status!=="uninitialized"&&M.dispatch(g(m)))}})}return S};function yt(e){let{reducerPath:r,queryThunk:c,api:g,context:p}=e,{apiUid:Q}=p,S={invalidateTags:U(`${r}/invalidateTags`)},E=d=>d.type.startsWith(`${r}/`),M=[it,tt,ot,at,rt,st];return{middleware:d=>{let n=!1,m={...e,internalState:{currentSubscriptions:{}},refetchQuery:x,isThisApiSliceAction:E},R=M.map(a=>a(m)),y=et(m),u=ut(m);return a=>o=>{if(!ve(o))return a(o);n||(n=!0,d.dispatch(g.internalActions.middlewareRegistered(Q)));let i={...d,next:a},s=d.getState(),[T,l]=y(o,i,s),h;if(T?h=a(o):h=l,d.getState()[r]&&(u(o,i,s),E(o)||p.hasRehydrationInfo(o)))for(let D of R)D(o,i,s);return h}},actions:S};function x(d){return e.api.endpoints[d.endpointName].initiate(d.originalArgs,{subscribe:!1,forceRefetch:!0})}}var he=Symbol(),Ee=({createSelector:e=Be}={})=>({name:he,init(r,{baseQuery:c,tagTypes:g,reducerPath:p,serializeQueryArgs:Q,keepUnusedDataFor:S,refetchOnMountOrArgChange:E,refetchOnFocus:M,refetchOnReconnect:f,invalidationBehavior:x},d){Ct();let n=w=>(typeof process<"u",w);Object.assign(r,{reducerPath:p,endpoints:{},internalActions:{onOnline:V,onOffline:ne,onFocus:z,onFocusLost:te},util:{}});let{queryThunk:t,mutationThunk:m,patchQueryData:R,updateQueryData:y,upsertQueryData:u,prefetch:a,buildMatchThunkActions:o}=_e({baseQuery:c,reducerPath:p,context:d,api:r,serializeQueryArgs:Q,assertTagType:n}),{reducer:i,actions:s}=We({context:d,queryThunk:t,mutationThunk:m,reducerPath:p,assertTagType:n,config:{refetchOnFocus:M,refetchOnReconnect:f,refetchOnMountOrArgChange:E,keepUnusedDataFor:S,reducerPath:p,invalidationBehavior:x}});L(r.util,{patchQueryData:R,updateQueryData:y,upsertQueryData:u,prefetch:a,resetApiState:s.resetApiState}),L(r.internalActions,s);let{middleware:T,actions:l}=yt({reducerPath:p,context:d,queryThunk:t,mutationThunk:m,api:r,assertTagType:n});L(r.util,l),L(r,{reducer:i,middleware:T});let{buildQuerySelector:h,buildMutationSelector:D,selectInvalidatedBy:A,selectCachedArgsForQuery:b}=Ye({serializeQueryArgs:Q,reducerPath:p,createSelector:e});L(r.util,{selectInvalidatedBy:A,selectCachedArgsForQuery:b});let{buildInitiateQuery:B,buildInitiateMutation:k,getRunningMutationThunk:P,getRunningMutationsThunk:C,getRunningQueriesThunk:O,getRunningQueryThunk:F}=Le({queryThunk:t,mutationThunk:m,api:r,serializeQueryArgs:Q,context:d});return L(r.util,{getRunningMutationThunk:P,getRunningMutationsThunk:C,getRunningQueryThunk:F,getRunningQueriesThunk:O}),{name:he,injectEndpoint(w,q){let N=r;N.endpoints[w]??={},le(q)?L(N.endpoints[w],{name:w,select:h(w,q),initiate:B(w,q)},o(t,w)):je(q)&&L(N.endpoints[w],{name:w,select:D(),initiate:k(w)},o(m,w))}}}});var wt=be(Ee());export{Qe as QueryStatus,Mt as _NEVER,be as buildCreateApi,pe as copyWithStructuralSharing,Ee as coreModule,he as coreModuleName,wt as createApi,Te as defaultSerializeQueryArgs,Bt as fakeBaseQuery,ft as fetchBaseQuery,ht as retry,Qt as setupListeners,ge as skipToken};
//# sourceMappingURL=rtk-query.browser.mjs.map